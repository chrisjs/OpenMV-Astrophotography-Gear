<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="initial-scale=1" />
<title>OpenMV PolarScope</title>

<style type="text/css">
body
{
    background-color: #000;
    color: #EEE;
    font-size: 10pt;
}
</style>

<script type="text/javascript">

var dataw = 2592;
var datah = 1944;

var first = true;
var settings = null;
var updateQueue = [];
var updatePending = [];
var lastStatus = null;
var prev_frm = -1;
var needUiRefresh = false;
var statusUpdateTimer;

var ghost = null;
var pre_ghost = null;
var ghost_results = null;

var jpgdata = false;
var prev_jpg = -1;

var hotpixels = [];

var loadTries = 0;

var refraction = null;

function loadSettings(t)
{
    if (platesolver_init !== undefined) {
        platesolver_init();
    }

    if (t == 0) {
        setTimeout(() => { loadSettings(1); }, 500);
        return;
    }

    $.ajax({
        dataType: "json",
        url: "getsettings",
        data: null,
        success: function(data) {
            console.log("settings retrieved");
            console.log(data);
            settings = data;
            try {
                var multi = 10000.0;
                document.getElementById("txt_location").value = (Math.round((settings["latitude"] + Number.EPSILON) * multi) / multi).toString() + " , " + (Math.round((settings["longitude"] + Number.EPSILON) * multi) / multi).toString();
            }
            catch (e) {
                console.log("cannot parse location from settings: " + e.toString());
            }
            document.getElementById("loading").style.display        = "none";
            document.getElementById("loading_failed").style.display = "none";
            document.getElementById("loading_almost").style.display = "block";
            onLoadAll();
        },
        fail: function(jqxhr, textStatus, error) {
            console.log("getsettings failed");
            console.log(txtStatus);
            console.log(error);
            loadSettingsFailed();
        },
        error: function() {
            console.log("getsettings error");
            loadSettingsFailed();
        }
    });
}

function loadSettingsFailed()
{
    loadTries += 1;
    console.log("settings load reattempt " + loadTries);
    document.getElementById("load_tries").innerHTML += ".";
    loadSettings(0);
}

function startLoadJpeg(t)
{
    loadJpeg();
    if (t < 500) {
        t = 500;
    }
    setTimeout(() => { startStatusUpdate(); }, t);
}

/*
I did attempt to use AJAX to load the JPEG but it doesn't work
The AJAX would actually complete but it would give an error
It has trouble parsing the binary data as text
The data is available but there's no way to convert it into base64

Also I've attempted to send over the JPEG data as base64
but this requires a lot more memory on the microcontroller
and streaming it in chunks is extremely slow

So for now, the best solution is to just use a plain <img> tag
with a URL that prevents caching
*/

function loadJpeg()
{
    var divele = document.getElementById("viewmejpeg");
    var jpegele = document.createElement("img");
    var d = get_draw_scale(1, false);
    jpegele.setAttribute("id", "jpegele");
    jpegele.setAttribute("src", "/getimg.jpg?t=" + updateTime()); // the query string forces the browser to not cache the request
    var imgw = d[2];
    var imgh = d[3];
    jpegele.style.width = imgw + "px";
    jpegele.style.height = imgh + "px";
    jpegele.style.opacity = "1.0";
    while (divele.firstChild) {
        divele.removeChild(divele.firstChild);
    }
    divele.appendChild(jpegele);
    jpgdata = true;
}

function startSendSettings()
{
    var i, ql = updateQueue.length;
    var str = "";
    for (i = 0; i < ql; i++)
    {
        var k = updateQueue[i];
        try {
            var ap = k + "=" + settings[k];
            if (i != 0) {
                str += "&";
            }
            str += ap;
            if (updatePending.includes(k) == false) {
                updatePending.push(k);
            }
        }
        catch (e) {
            
        }
    }
    updateQueue = [];
    onSettingErr = function () {
        // setting saving failed
        // so queue them back up again
        // only re-send when status update is successful
        updatePending.forEach(function(ele) {
            if (updateQueue.includes(ele) == false) {
                updateQueue.push(ele);
            }
        });
        updatePending = [];
        startStatusUpdate();
    };

    var url = "/updatesetting?" + str;
    console.log(str);

    $.get({
        url: url,
        success: function() {
            updatePending = [];
            startStatusUpdate();
        },
        fail:  function () { onSettingErr(); },
        error: function () { onSettingErr(); }
    });
}

function startStatusUpdate() {
    var qstr = "";
    if ($( "#realmode-1").prop("checked")) {
        qstr += "packjpeg=true&";
    }
    else {
        qstr += "packjpeg=false&";
        var divele = document.getElementById("viewmejpeg");
        while (divele.firstChild) {
            divele.removeChild(divele.firstChild);
        }
        jpgdata = false;
    }
    if ($( "#speedmode-2").prop("checked")) {
        qstr += "highspeed=true&";
    }
    else {
        qstr += "highspeed=false&";
    }
    qstr += "zoom=" + get_zoom().toString() + "&";

    qstr += "time=" + updateTime();

    $.ajax({
        dataType: "json",
        url: "getstate?" + qstr,
        success: endStatusUpdate,
        fail: failStatusUpdate,
        error: errorStatusUpdate,
        timeout: 5000
    });
}

function endStatusUpdate(obj) {
    console.log("status: " + obj);

    if (obj == null || obj == false || obj == undefined) {
        document.getElementById("connection_lost").style.display = "block";
        setTimeout(() => { startStatusUpdate(); }, 5000);
    }

    lastStatus = obj;

    document.getElementById("loading_almost").style.display = "none";
    document.getElementById("connection_lost").style.display = "none";
    document.getElementById("showme").style.display = "block";

    var nextSts;
    if (obj["highspeed"] == false) {
        nextSts = settings["shutter"] / 2;
    }
    else {
        nextSts = settings["shutter_hs"] / 2;
    }
    nextSts /= 1000;
    if (nextSts < 500) {
        nextSts = 500;
    }

    if (updateQueue.length > 0)
    {
        startSendSettings();
    }
    else if ($( "#realmode-1").prop("checked") && prev_jpg != obj["frm_cnt"])
    {
        prev_jpg = obj["frm_cnt"];
        startLoadJpeg(nextSts);
    }
    else {
        setTimeout(() => { startStatusUpdate(); }, nextSts);
    }

    if (first)
    {
        if (obj["highspeed"]) {
            $( "#speedmode-1" ).prop("checked", false);
            $( "#speedmode-2" ).prop("checked", true);
        }
        $( "#realmode-1" ).prop("checked", obj["packjpeg"]);
        first = false;
    }

    updateTime();

    if (prev_frm == obj["frm_cnt"] && needUiRefresh == false) {
        return;
    }
    prev_frm = obj["diag_frm_cnt"];

    refreshUi(obj);
}

function refreshUi(obj)
{
    if (obj == null) {
        obj = lastStatus;
    }
    if (obj == null) {
        return;
    }
    lastStatus = obj;

    if (obj["expo_code"] === 6) {
        document.getElementById("memory_error").style.display = "block";
    }
    else {
        document.getElementById("memory_error").style.display = "none";
    }

    var stars = obj["stars"];
    var star_cnt = stars.length;

    var stats_str = "num of stars: " + star_cnt.toString() + "&nbsp;&nbsp;&nbsp;&nbsp;";

    stats_str += "image mean: "  + Math.round(obj["img_mean"]).toString() + "/255    \t";
    stats_str += "image stdev: " + Math.round(obj["img_stdev"]).toString() + "/255    \t";
    stats_str += "image max: " + Math.round(obj["img_max"]).toString() + "/255    \t";
    stats_str += "image min: " + Math.round(obj["img_min"]).toString() + "/255    \t";
    stats_str += "exposure code: ";
    var exposure_code = obj["expo_code"];
    stats_str += getExposureCode(exposure_code);
    while (stats_str.includes(" ")) {
        stats_str = stats_str.replace(" ", "&nbsp;");
    }
    document.getElementById("div_histogram").innerHTML = stats_str;

    var vg = validateGhost();
    var canCalibrate = vg[0];
    var reason = vg[1];

    var curCalDataEle = document.getElementById("div_curdata");
    if (obj["solution"] && obj["star_x"] && obj["star_y"] && obj["pole_x"] && obj["pole_y"])
    {
        var s = "Polaris = (" + obj["star_x"] + ", " + obj["star_y"] + ")  ;  NCP = (" + obj["pole_x"] + ", " + obj["pole_y"] + ")";
        if (canCalibrate == false && ghost != null) {
            s += " ; cannot calibrate with this" + reason;
        }
        curCalDataEle.innerHTML = s;
        pre_ghost = {star_x: obj["star_x"], star_y: obj["star_y"], pole_x: obj["pole_x"], pole_y: obj["pole_y"]};
        $("#btn_regimg" ).button( "option", "disabled", false );
    }
    else
    {
        curCalDataEle.innerHTML = "nothing";
        pre_ghost = null;
        canCalibrate = false;
        $("#btn_regimg" ).button( "option", "disabled", true );
    }

    var ghostDataEle = document.getElementById("div_caldata");
    if (ghost != null)
    {
        ghostDataEle.innerHTML = "Polaris = (" + ghost.star_x + ", " + ghost.star_y + ")  ;  NCP = (" + ghost.pole_x + ", " + ghost.pole_y + ")";
        $("#btn_clearregimg" ).button( "option", "disabled",  false);
    }
    else
    {
        ghostDataEle.innerHTML = "nothing";
        canCalibrate = false;
        $("#btn_clearregimg" ).button( "option", "disabled", true );
    }

    $("#btn_calibrate" ).button( "option", "disabled", canCalibrate == false );

    draw_svg(obj, get_zoom(), needUiRefresh, false, jpgdata, ghost_results);

    needUiRefresh = false;
}

function validateGhost()
{
    ghost_results = math_getGhostResults(lastStatus, ghost);
    var canCalibrate = pre_ghost != null;
    var reason = "";
    if (ghost_results != null)
    {
        if (ghost_results.cent_x != null && ghost_results.cent_x != 0)
        {
            // being too off-center will make plate-solving much harder
            if (ghost_results.cent_x < dataw * 0.33 || ghost_results.cent_x > dataw * 0.67) {
                canCalibrate = false;
                reason = ", too off-center";
            }
            if (ghost_results.cent_y < datah * 0.33 || ghost_results.cent_y > datah * 0.67) {
                canCalibrate = false;
                reason = ", too off-center";
            }
        }
        else {
            canCalibrate = false;
            reason = ", calculation failed";
        }
    }
    else {
        reason = ", unable to calculate";
    }
    return [canCalibrate, reason];
}

function updateTime() {
    var newEpoch = Date.UTC(2000, 1, 1); 
    date = new Date();
    var nowEpoch = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    nowEpoch -= newEpoch;
    nowEpoch = Math.round(nowEpoch / 1000.0);
    document.getElementById("span_utc_time").innerHTML = date.toUTCString();
    document.getElementById("span_utc_time_epoch").innerHTML = nowEpoch.toString();
    return nowEpoch;
}

function errorStatusUpdate() {
    console.log("getstate error\r\n");
    document.getElementById("connection_lost").style.display = "block";
    document.getElementById("showme").style.display          = "block";
    setTimeout(() => { startStatusUpdate(); }, 5000);
}

function failStatusUpdate(jqxhr, textStatus, error) {
    console.log("getstate failed\r\n" + textStatus.toString() + "\r\n" + error.toString());
    document.getElementById("connection_lost").style.display = "block";
    document.getElementById("showme").style.display          = "block";
    setTimeout(() => { startStatusUpdate(); }, 5000);
}

function getExposureCode(exposure_code) {
    if (exposure_code == 0) {
        return "correct";
    }
    else if (exposure_code == -1) {
        return "too dark";
    }
    else if (exposure_code == 1) {
        return "too bright";
    }
    else if (exposure_code == 2) {
        return "too noisy";
    }
    else if (exposure_code == 3) {
        return "movement";
    }
    else if (exposure_code == 4) {
        return "big blob";
    }
    else if (exposure_code == 5) {
        return "too many stars";
    }
    else if (exposure_code == 6) {
        return "INTERNAL MEMORY ERROR";
    }
    return "unknown";
}

function getLocation() {
    var xele = document.getElementById("txt_location");
    var x = xele.value;

    // split the user input into two halves
    var split;
    if (x.includes(",")) {
        split = x.split(",");
    }
    else if (x.includes(";")) {
        split = x.split(";");
    }
    else if (x.includes("/")) {
        split = x.split("/");
    }
    else if (x.includes("\t")) {
        split = x.split("\t");
    }
    else {
        xele.style.backgroundColor = "pink";
        return false;
    }
    if (split.length != 2) {
        xele.style.backgroundColor = "pink";
        return false;
    }

    // we expect the two numbers to be in a specific order, but putting a direction could change that order
    var s0 = split[0].trim().toUpperCase();
    var s1 = split[1].trim().toUpperCase();
    if ((s0.includes("N") || s0.includes("S")) && (s1.includes("E") || s1.includes("W"))) {
        var s3 = s0;
        s0 = s1;
        s1 = s3;
    }

    // let magellan take care of the rest of the parsing
    var latitude  = magellan(s0).latitude();
    var longitude = magellan(s1).longitude();
    if (longitude == null || latitude == null) {
        xele.style.backgroundColor = "pink";
        return false;
    }
    xele.style.backgroundColor = "";
    return [parseFloat(longitude.toDD()), parseFloat(latitude.toDD())];
}

function queueSettingsUpdate(key) {
    if (updateQueue.includes(key) == false) {
        updateQueue.push(key);
        console.log("queueing setting update for " + key);
    }
}

function computeRefraction() {
    if ($( "#chkrefraction-1").prop("checked") == false) {
        document.getElementById("refraction_info").innerHTML = "";
        refraction = null;
        return;
    }
    var loc = getLocation();
    if (loc == false) {
        document.getElementById("refraction_info").innerHTML = "Unable to calculate refraction due to invalid location coordinates";
        refraction = null;
        return;
    }
    refraction = math_getRefraction(loc[1], $("#slider_pressure").slider("option", "value") / 10.0, $("#slider_temperature").slider("option", "value"));
    var fmtRefraction = "" + refraction[0];
    while (true) {
        var i, c = 0;
        for (i = 0; i < fmtRefraction.length; i++) {
            if (fmtRefraction[i] != '0') {
                c += 1;
            }
        }
        if (c < 3) {
            break;
        }
        if (fmtRefraction.length < 8) {
            break;
        }
        fmtRefraction = fmtRefraction.substring(0, fmtRefraction.length - 1);
    }
    var txtinfo = "Calculated Refraction: " + fmtRefraction + "&deg; = " + (Math.round(refraction[1] * 100.0) / 100.0) + " arcmin";
    if (lastStatus != null && lastStatus != false) {
        if (lastStatus["solution"]) {
            txtinfo += " = " + (Math.round(lastStatus["pix_per_deg"] * refraction[0] * 10.0) / 10.0) + " camera pixels";
        }
    }
    document.getElementById("refraction_info").innerHTML = txtinfo;
}

function checkHotPixel(star) {
    if (hotpixels == undefined) {
        return false;
    }
    if (hotpixels == null || hotpixels == false) {
        return false;
    }
    if (hotpixels.length <= 0) {
        return false;
    }
    var i, cnt = hotpixels.length;
    for (i = 0; i < cnt; i++) {
        var v = math_getVector([star.cx, star.cy], hotpixels[i]);
        if (v[0] < 2) {
            return true;
        }
    }
    return false;
}

function demoGhost()
{
    var needGood = Math.random() < 0.5;
    var tries = 0;
    while (tries < 50)
    {
        var v = math_getVector([ghost.star_x, ghost.star_y], [ghost.pole_x, ghost.pole_y]);
        ghost.star_x = Math.round((dataw * 0.2) + (Math.random() * dataw * 0.6));
        ghost.star_y = Math.round((datah * 0.2) + (Math.random() * datah * 0.6));
        var p = math_movePointTowards([ghost.star_x, ghost.star_y], [v[0], v[1] + (90.0 * (-1.5 + (Math.random() * 3.0)))]);
        ghost.pole_x = Math.round(p[0]);
        ghost.pole_y = Math.round(p[1]);
        if (needGood) {
            var vg = validateGhost();
            if (vg[0]) {
                break;
            }
        }
        else if (needGood == false && ghost.pole_x > 0 && ghost.pole_x < dataw && ghost.pole_y > 0 && ghost.pole_y < datah) {
            break;
        }
        tries += 1;
    }
}

function makeSlider(id, minval, maxval, defval, stepval, slide_func)
{
    if (defval < minval) {
        defval = minval;
    }
    if (defval > maxval) {
        defval = maxval;
    }

    var handle = $( "#" + id + "_handle" );
    $( "#" + id ).slider({
      create: function() {
        handle.text( $( this ).slider( "value" ) );
      },
      min: minval,
      max: maxval,
      step: stepval,
      value: defval,
      slide: function( event, ui ) {
        handle.text( ui.value );
        if (slide_func) {
            slide_func(this, event, ui);
        }
      }
    });
}

function onLoadAll()
{
    document.getElementById("loading").style.display = "none";
    $( "#accordion" ).accordion({heightStyle: "content"});

    $( "#fldset_zoom  input" ).checkboxradio();
    $( "#viewmode-1").prop("checked", true).checkboxradio("refresh");
    $( "#fldset_speed input" ).checkboxradio();
    $( "#speedmode-1").prop("checked", true).checkboxradio("refresh");
    $( "#chkrefraction-1" ).checkboxradio().prop("checked", settings["use_refraction"]).on("change", function () {
        var x = getLocation();
        var y = $( "#chkrefraction-1").prop("checked");
        if (x == false && y == true) {
            $( "#chkrefraction-1").prop("checked", false).checkboxradio("refresh");
            alert("ERROR: Proper location coordinates required for refraction calculations");
            return;
        }
        if (settings["use_refraction"] !== y) {
            settings["use_refraction"] = y;
            queueSettingsUpdate("use_refraction");
        }
        if (y) {
            computeRefraction();
        }
        else {
            document.getElementById("refraction_info").innerHTML = "";
        }
        refreshUi(null);
    }).checkboxradio("refresh");

    $( "#realmode-1" ).checkboxradio().on("change", function () {
        var x = $( "#realmode-1").prop("checked");
        console.log("realmode click " + x);
        //if (x) {
        //    $( "#viewmode-4").prop("checked", false).checkboxradio("refresh");
        //    $( "#viewmode-3").prop("checked", false).checkboxradio("refresh");
        //    $( "#viewmode-2").prop("checked", false).checkboxradio("refresh");
        //    $( "#viewmode-1").prop("checked", true).checkboxradio("refresh");
        //}
        refreshUi(null);
    });;

    makeSlider("slider_gain_slow", 0, 128, settings["gain"], 8, function(obj, event, ui) {
        console.log("slider_gain_slow: " + ui.value);
        settings["gain"] = ui.value;
        queueSettingsUpdate("gain");
    });
    makeSlider("slider_shutter_slow", 0, 1500, settings["shutter"] / 1000, 100, function(obj, event, ui) {
        console.log("slider_shutter_slow: " + ui.value);
        settings["shutter"] = ui.value * 1000;
        queueSettingsUpdate("shutter");
    });
    makeSlider("slider_thresh_slow", 0, 255, settings["thresh"], 1, function(obj, event, ui) {
        console.log("slider_thresh_slow: " + ui.value);
        settings["thresh"] = ui.value;
        queueSettingsUpdate("thresh");
    });
    makeSlider("slider_gain_fast", 0, 128, settings["gain_hs"], 8, function(obj, event, ui) {
        console.log("slider_gain_fast: " + ui.value);
        settings["gain_hs"] = ui.value;
        queueSettingsUpdate("gain_hs");
    });
    makeSlider("slider_shutter_fast", 0, 1500, settings["shutter_hs"] / 1000, 100, function(obj, event, ui) {
        console.log("slider_shutter_fast: " + ui.value);
        settings["shutter_hs"] = ui.value * 1000;
        queueSettingsUpdate("shutter_hs");
    });
    makeSlider("slider_thresh_fast", 0, 255, settings["thresh_hs"], 1, function(obj, event, ui) {
        console.log("slider_thresh_fast: " + ui.value);
        settings["thresh_hs"] = ui.value;
        queueSettingsUpdate("thresh_hs");
    });
    makeSlider("slider_pressure", 500, 1100, 1010, 1, function(obj, event, ui) {
        console.log("slider_pressure: " + ui.value);
        var x = ui.value / 10;
        document.getElementById("span_pressure").innerHTML = x + " kPa";
        computeRefraction();
        refreshUi(null);
    });
    document.getElementById("span_pressure").innerHTML = "101 kPa";
    makeSlider("slider_temperature", -50, 50, 10, 1, function(obj, event, ui) {
        console.log("slider_temperature: " + ui.value);
        document.getElementById("span_temperature").innerHTML = ui.value + "&deg;C";
        computeRefraction();
        refreshUi(null);
    });
    document.getElementById("span_temperature").innerHTML = "10&deg;C";

    $("#btn_time_update" ).button().click(function( event ) {
        console.log("click btn_time_update");
        settings["time"] = updateTime();
        queueSettingsUpdate("time");
        refreshUi(null);
    });

    $("#btn_location_update" ).button().click(function( event ) {
        console.log("click btn_location_update");
        var x = getLocation();
        if (x != false) {
            console.log(x[0] + " ; " + x[1]);
            settings["longitude"] = x[0];
            settings["latitude"] = x[1];
            document.getElementById("txt_location").style.backgroundColor = "#7FAF00";
            settings["time"] = updateTime();
            queueSettingsUpdate("time");
            queueSettingsUpdate("longitude");
            queueSettingsUpdate("latitude");
        }
        refreshUi(null);
    });

    $("#btn_regimg" ).button().click(function( event ) {
        console.log("click btn_regimg");
        ghost = pre_ghost;

        var demo = false;
        if (demo)
        {
            demoGhost();
        }

        // calibrate button is enabled when the solution is checked against
        refreshUi(null);
    });

    $("#btn_clearregimg").button().click(function( event ) {
        console.log("click btn_clearregimg");
        ghost = null;
        pre_ghost = null;
        $("#btn_calibrate" ).button( "option", "disabled", true );
        document.getElementById("div_caldata").innerHTML = "nothing";
        refreshUi(null);
    });

    $("#btn_calibrate").button().click(function( event ) {
        console.log("click btn_calibrate");
        if (ghost_results != null)
        {
            if (ghost_results.cent_x != 0 && ghost_results.cent_x != null && ghost_results.cent_y != 0 && ghost_results.cent_y != null)
            {
                settings["center_x"] = ghost_results.cent_x;
                settings["center_y"] = ghost_results.cent_y;
                queueSettingsUpdate("center_x");
                queueSettingsUpdate("center_y");
                alert("calibration done!");
            }
            else {
                alert("ERROR: no solution for calibration!");
            }
        }
        else {
            alert("ERROR: no solution for calibration!");
        }
        refreshUi(null);
    });

    $("#btn_hotpixels").button().click(function( event ) {
        hotpixels = [];
        var pixstr = "";
        var settingsStr = "";
        if (lastStatus != null) {
            var stars = lastStatus["stars"];
            stars.forEach(function(ele, idx) {
                //if (ele["brightness"] % 2 == 1) // odd number means contains saturated pixel
                // nevermind, a hot pixel isn't necessarily saturated
                {
                    hotpixels.push([ele["cx"], ele["cy"]]);
                }
            });
        }
        else {
            pixstr = "Error: no data from camera";
        }
        var divele = document.getElementById("hotpixel_list");
        if (hotpixels.length > 0)
        {
            pixstr += "<ol>";
            hotpixels.forEach(function(ele, idx) {
                pixstr += "<li>( " + (Math.round(ele[0] * 10.0) / 10.0) + " , " + (Math.round(ele[1] * 10.0) / 10.0) + " )</li>";
                settingsStr += (Math.round(ele[0] * 10.0) / 10.0) + "," + (Math.round(ele[1] * 10.0) / 10.0) + ";";
            });
            pixstr += "</ol>";
            settings["hotpixels"] = settingsStr;
            queueSettingsUpdate("hotpixels");
        }
        else
        {
            pixstr = "No hot-pixels detected by camera";
        }
        divele.innerHTML = pixstr;
    });

    $("#btn_forgethotpixels").button().click(function( event ) {
        hotpixels = [];
        var divele = document.getElementById("hotpixel_list");
        divele.innerHTML = "";
        settings["hotpixels"] = "";
        queueSettingsUpdate("hotpixels");
    });

    document.getElementById("txt_location").onchange = function() {
        getLocation(); // just to validate and colorize
        computeRefraction();
        refreshUi(null);
    };

    $(window).on('resize', function(e) {
        needUiRefresh = true; // this will force a re-scaling of the drawn view
    });

    computeRefraction();

    setTimeout(() => { startStatusUpdate(); }, 1000);
}

</script>

</head>
<body onload="loadSettings(0);">
<div id="loading"><h2>OpenMV PolarScope</h2><br /><h2>Loading, Please Wait! <span id="load_tries"></span></h2></div>
<div id="loading_failed" style="display:none;"><h1>Loading FAILED! Please refresh the page.</h1></div>
<div id="loading_almost" style="display:none;"><h2>OpenMV PolarScope</h2><br /><h2>Settings loaded! Waiting for star data...</h2></div>
<div id="showme" style="display:none;">

<div style="width:100%"><fieldset style="padding-top: 1em;"><legend>OpenMV PolarScope</legend><div id="viewme" style="display: inline-block; width:100%; padding: 0 0 0 0; margin: 0 0 0 0;"><div id="viewmejpeg" style="position: relative; z-index: 1"></div><div id="viewmesvg" style="position: relative; z-index: 2; top: 0; left: 0;">&nbsp;&nbsp;Please wait for image...</div>
</div></fieldset></div>

<div id="connection_lost" class="ui-widget" style="display: none;"><div id="connection_lost_inner" class="ui-state-error ui-corner-all .ui-state-error-text" ><p>&nbsp;&nbsp;Connection LOST! Attempting to re-establish...</p></div></div>
<div id="memory_error" class="ui-widget" style="display: none;"><div id="memory_error_inner" class="ui-state-error ui-corner-all .ui-state-error-text" ><p>&nbsp;&nbsp;INTERNAL MEMORY ERROR! Please check the camera exposure settings!</p></div></div>

<div id="accordion">
  <h3>View Mode</h3>
  <div>
    <div><fieldset id="fldset_zoom"><legend>Zoom</legend><form>
    <label for="viewmode-1">1x</label>
    <input type="radio" name="viewmode-1" id="viewmode-1" />
    <label for="viewmode-2">2x</label>
    <input type="radio" name="viewmode-1" id="viewmode-2" />
    <label for="viewmode-3">4x</label>
    <input type="radio" name="viewmode-1" id="viewmode-3" />
    <label for="viewmode-4">8x</label>
    <input type="radio" name="viewmode-1" id="viewmode-4" />
    </form></fieldset></div>
    <div><fieldset id="fldset_speed"><legend>Speed</legend><form>
    <label for="speedmode-1">Normal</label>
    <input type="radio" name="speedmode-1" id="speedmode-1" />
    <label for="speedmode-2">Fast</label>
    <input type="radio" name="speedmode-1" id="speedmode-2" />
    </form></fieldset></div>
    <p><label for="realmode-1">Real Image</label>
    <input type="checkbox" name="realmode-1" id="realmode-1" /></p>
    <p>The normal mode will identify Polaris and the position of the North Celestial Pole (NCP) by pattern-matching the stars around it. The fast mode will assume the brightest star is Polaris, and track the NCP using previous data, making it easy to make adjustments on your mount.</p>
    <p>The real image mode is used to check exposure and focus. Note that the image is processed at a high resolution (for precise polar alignment) but is transmitted at a low quality (for faster WiFi file transfer speed).</p>
    <p>For the most precise alignment, please use the available zoom level buttons, not finger-pinch.</p>
  </div>
  <h3 id="title_platesolve">Plate Solve</h3>
  <div>
    <p>This camera has a database of about 2740 stars that are within 45&deg; of Polaris, and can attempt to identify about 500 of them (one that are bright, B-mag &lt;= 5). Clicking the button below will attempt to identify the star closest to the crosshair. If it has been identified, you can try navigating a sky map with the identified star.</p>
    <p>This algorithm can be painfully slow, but it is searching from Polaris and outwards. Thus, the closer you point towards Polaris, you can stop the calculations earlier.</p>
    <p><button id="btn_platesolve">Plate Solve</button><button id="btn_platesolvehalt">Stop</button></p>
    <div><fieldset><legend>Solution</legend><div id="div_platesolvesolution"></div></fieldset></div>
  </div>
  <h3>Center Calibration</h3>
  <div>
    <p>The center of the camera view may not be perfectly aligned with the center-of-rotation of your star tracker. Two images of Polaris is required to calibrate the center-of-rotation. For the best result, the two images should be rotated about 90&deg; apart.</p>
    <p>To start, rotate your star tracker's Right-Ascension (RA) to a position towards the west. Register the data in "First Image Data" when you are satisfied. Then, rotate your star tracker's RA about 90&deg; towards the east. Click the "calibrate" button when you are satisfied.</p>
    <p>Avoid using your hands to make these movements, use electronic control if possible. Do not move your tripod or adjust your mount during these movements. If the center-of-rotation is too far away from the center-of-view, you may need to adjust the mounting of the camera.</p>
    <div><fieldset id="fldset_curdata"><legend>Current Image Data</legend>
        <div id="div_curdata">nothing yet</div>
    </fieldset></div>
    <div><fieldset id="fldset_caldata"><legend>First Image Data</legend>
        <div id="div_caldata">nothing yet</div>
    </fieldset></div>
    <div><button id="btn_regimg">Register Image Data</button>&nbsp;&nbsp;<button id="btn_calibrate">Calibrate</button>&nbsp;&nbsp;<button id="btn_clearregimg">Clear Data</button></div>
  </div>
  <h3>Time and Location</h3>
  <div>
    <div><fieldset><legend>Time and Date</legend><div><p>UTC Time: <span id="span_utc_time"></span></p><p>Epoch Seconds: <span id="span_utc_time_epoch"></span></p><p style="display: none;"><button id="btn_time_update">Update</button></p></div></fieldset></div>
    <div><fieldset><legend>Location</legend><div><p>type in or paste in coordinates</p><p>latitude, longitude</p><p>comma separated, multiple formats supported (automatically detected)</p><p><input type="text" name="txt_location" id="txt_location" style="width: 100%;" /><button id="btn_location_update">Save</button></p></div></fieldset></div>
    <p>The time and date information is used to calculate the position of Polaris while compensating for the very slow wobble of the Earth's rotation axis. The location information is used to help determine the atmospheric refraction compensation required.</p>
    <div><fieldset><legend>Atmosphere Conditions</legend><div><p>Pressure and temperature does affect the air's index of refraction, by very little amounts. Default values are 101 kPa and 10&deg;C.</p>
        <p><fieldset><legend>Pressure: <span id="span_pressure"></span></legend><div id="slider_pressure"></div></fieldset></p>
        <p><fieldset><legend>Temperature: <span id="span_temperature"></span></legend><div id="slider_temperature"></div></fieldset></p>
    <p></p></div></fieldset></div>
    <p><label for="chkrefraction-1">Apply Refraction Compensation?</label>
    <input type="checkbox" name="chkrefraction-1" id="chkrefraction-1"></p>
    <p id="refraction_info"></p>
  </div>
  <h3>Camera Exposure</h3>
  <div>
    <div><fieldset><legend>Statistics</legend>
    <div id="div_histogram"></div>
    </fieldset></div>
    <div><fieldset><legend>Gain - Slow Mode: <span id="slider_gain_slow_handle"></span> dB</legend>
        <div id="slider_gain_slow"></div>
    </fieldset></div>
    <div><fieldset><legend>Shutter - Slow Mode: <span id="slider_shutter_slow_handle"></span> ms</legend>
        <div id="slider_shutter_slow"></div>
    </fieldset></div>
    <div><fieldset><legend>Star Threshold - Slow Mode: <span id="slider_thresh_slow_handle"></span>/255</legend>
        <div id="slider_thresh_slow"></div>
    </fieldset></div>
    <div><fieldset><legend>Gain - Fast Mode: <span id="slider_gain_fast_handle"></span> dB</legend>
        <div id="slider_gain_fast"></div>
    </fieldset></div>
    <div><fieldset><legend>Shutter - Fast Mode: <span id="slider_shutter_fast_handle"></span> ms</legend>
        <div id="slider_shutter_fast"></div>
    </fieldset></div>
    <div><fieldset><legend>Star Threshold - Fast Mode: <span id="slider_thresh_fast_handle"></span>/255</legend>
        <div id="slider_thresh_fast"></div>
    </fieldset></div>
  </div>
  <h3>Hot Pixels</h3>
  <div>
    <p>If the camera gets too hot, there will be pixels that appear to be stuck as white. These stuck pixels will be falsely detected as stars. You will notice these pixels when you see stars that do not move even though you are moving the camera around.</p>
    <p>It is possible to memorize which pixels are stuck so that they are removed from the list of stars. To do so: <ol><li>turn up the gain and shutter time slightly</li><li>cover up the camera completely</li><li>click the "capture hot pixels" button</li><li>restore your original settings</li></ol></p>
    <p>Think of this as taking a "dark frame" but not really the same thing.</p>
    <p>If a hot pixel is near where an important star exists, then rotate the camera.</p>
    <p><button id="btn_hotpixels">Capture Hot Pixels</button><button id="btn_forgethotpixels">Forget Hot Pixels</button></p>
    <p><fieldset><legend>Hot Pixel List</legend><div id="hotpixel_list"></div></fieldset></p>
  </div>
</div><!-- accordion -->
</div><!-- showme -->
</body>
</html>